//
//  ViewController.m
//  ZPHash
//
//  Created by 赵鹏 on 2018/12/9.
//  Copyright © 2018 赵鹏. All rights reserved.
//

/**
 在开发过程中可以通过如下的三种加密方式对数据进行加密：
 1、哈希函数，也称为散列函数，可以分为如下的五种加密方式：
 （1）MD5加密，加密后的散列值（哈希值）为32个字符；
 （2）SHA1加密，加密后的散列值为40个字符；
 （3）SHA256加密，加密后的散列值为64个字符；
 （4）SHA512加密，加密后的散列值为128个字符；
 （5）HMAC加密。
 2、对称加密算法，可以分为如下的三种加密方式：
 （1）DES加密；
 （2）3DES加密；
 （3）AES加密（高级密码标准）。
 3、非对称加密算法：
 这种加密方式只有RSA加密算法一种加密方式。
 
 哈希函数：
 1、概念：Hash，一般翻译做”散列”，也有直接音译为“哈希”的，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值，也称为哈希值。这种转换是一种压缩映射，也就是散列值的空间通常远小于输入的空间。不同的输入可能会散列成相同的输出，所以不能从散列值来确定唯一的输入值。简单的说哈希函数就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。
 2、特点：
 （1）算法是公开的；
 （2）对相同的数据进行运算，得到的结果是一样的；
 （3）对不同的数据进行运算，也有可能得到相同的结果，所以不能从散列值（哈希值）来确定唯一的输入值。
 （4）哈希算法没有办法通过逆运算得到原来的值；
 （5）信息摘要，信息“指纹”，是用来做数据识别的。
 3、用途：
 （1）用户密码的加密；
 （2）搜索引擎；
 （3）版权；
 （4）数字签名。
 
 用户的隐私信息（比如登录密码）不能用RSA算法进行加密。在客户端用户输入完登录密码并且点击登录按钮之后，客户端会先把登录密码（字符串类型）转换成二进制数据类型，然后再利用提前已经获得到的服务器端的公钥给这个二进制的数据进行RSA加密，得到的加密结果也是一个二进制的数据，然后把这个加密结果进行Base64编码，得到的是一个字符串类型的数据，最后再进行网络传输，把加密后的结果传送给服务器。服务器在得到加密结果之后，利用自己的私钥对其进行解密，就能直接获得到用户密码的原文了，然后把这个密码原文再跟数据库里面存储的该用户的密码进行比对，从而判断出用户输入的密码是否正确。之所以不能用RSA算法来对用户隐私信息进行加密其原因就在于服务器端会存储这些用户隐私信息的明文，用来与客户端传递过来的信息进行比对，这样的话外界就有可能窃取服务器端的数据库从而泄露用户的隐私信息，或者服务器端的开发人员也可以直接泄露这些信息。
 
 关于用户隐私信息的两个禁忌：
 1、网络上不允许明文传递用户的隐私信息；
 2、本地不允许明文保存用户的隐私信息。
 一般把通过哈希算法得到的散列值（哈希值）保存到服务器的数据库中。因为通过散列值不能逆推得到原来的值，所以即便服务器端的源码和数据库被盗了，用户的隐私信息还是泄露不了。
 */
#import "ViewController.h"
#import "NSString+Hash.h"

@interface ViewController ()

@end

@implementation ViewController

#pragma mark ————— 生命周期 —————
- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    
    //MD5加密
//    [self md5Encrypt];
    
    //MD5加盐加密
//    [self md5SaltEncrypt];
    
    //HMAC加密
    [self HMACEncrypt];
}

#pragma mark ————— MD5加密 —————
- (void)md5Encrypt
{
    //原始密码
    NSString *originalPwd = @"123456";
    
    /**
     MD5加密不安全，因为对于相同的数据进行MD5加密的话会得到相同的结果，所以可以利用这一点进行暴力破解（反查询）。
     */
    NSString *encryptPwd = originalPwd.md5String;
    NSLog(@"MD5加密后的密码为：%@", encryptPwd);
}

#pragma mark ————— MD5加盐加密 —————
- (void)md5SaltEncrypt
{
    //盐：一般要写的复杂一些
    static NSString * salt = @"(*(*(DS*YFHIUYF(*&DSFHUS(*AD&";
    
    //原始密码
    NSString *originalPwd = @"123456";
    
    /**
     一般经过MD5加盐加密运算之后得到的结果不能反查询到原始数据，但是这种加密方式也不安全，原因就在于所加的“盐”是固定写死在程序里面的，开发人员能得到，这样就有泄露的风险。
     */
    NSString *encryptPwd = [originalPwd stringByAppendingString:salt].md5String;
    NSLog(@"MD5加盐加密后的密码：%@", encryptPwd);
}

#pragma mark ————— HMAC加密 —————
/**
 这种加密方式是目前主流的在登录的时候加密用户密码的方式。
 */
- (void)HMACEncrypt
{
    //原始密码
    NSString *originalPwd = @"123456";
    
    /**
     HMAC加密是使用一个密钥(Key)进行加密，并且做两次散列（调用两次哈希函数）；
     在实际开发过程中，密钥来源于服务器，是一个动态的密钥（动态盐）；
     客户端的一个账号对应一个密钥，并且可以更新。即便被第三方拿到了密钥，也只能破解一个用户的密码，不会造成大范围密码泄露的情况；
     在用户注册账号的时候，客户端会把账号名称发送给服务器，服务器进行验证，如果服务器的数据库中没有这个账号名称则允许客户端进行注册，此时服务器会把密钥(Key)发送给客户端，客户端把这个密钥存储到本地，以后用户再登录的时候这个密钥就当做HMAC加密的密钥了，对登录密码进行加密，再把加密过后的字符串类型的数据发送给服务器；
     当用户换手机以后，在使用APP进行首次登录的时候，当登录成功以后服务器会把密钥(Key)发送给客户端（新手机），客户端把这个密钥存储到本地，跟上述的一样，以后用户再登录的时候这个密钥就当做HMAC加密的密钥了，对登录密码进行加密，再把加密过后的字符串类型的数据发送给服务器；
     上述的两种情况，Key都只在注册成功或首次登录成功的情况下，服务器把密钥传递给了客户端，然后客户端就存在了本地，用来为以后的HMAC加密使用，除此之外，Key都不再在客户端和服务器之间进行传递了，这就大大地减少了Key被第三方窃取的危险；
     上述的Key可以定期进行更换；
     上述的Key相当于平时开发过程中的Token。
     */
    NSString *hmacPwd = [originalPwd hmacMD5StringWithKey:@"hello"];
    NSLog(@"HMAC加密后的密码：%@", hmacPwd);
    
    /**
     如果把上述的只经过HMAC加密后的字符串数据发送给服务器的话，第三方也可能会窃取到这个加密后的字符串，然后在其他的时间利用窃取到的字符串获得客户端的登录权限，对客户端做更改之类的操作；
     为了避免上述情况的发生，需要在经过HMAC加密后的字符串后面再拼接上一个服务器的时间戳（只到分钟，不到秒），然后把这个新的字符串再进行MD5加密，把加密后的字符串传递给服务器。服务器之前在客户端注册的时候也保留了一个经过HMAC加密后的字符串，所以当服务器接收到客户端传递过来的字符串后，服务器自己再把本地之前存储的HMAC加密字符串与当前的时间戳拼接，然后进行MD5加密，再与客户端传递过来的字符串相比较，如果相同则证明登录成功，如果不相同，服务器还会再进行一次比较，这次服务器把时间戳往前倒一分钟，为了防止客户端传送字符串的时候是上一分钟的最后一秒，到达服务器的时候就变成了下一分钟的情况，然后再经过上述相同的步骤得到的字符串再与客户端传递过来的相比较，如果相同则证明登录成功，如果不同，则证明登录失败。但是这种情况还是有漏洞，漏洞就是当第三方从服务器获取到经过HMAC加密后的字符串后，再模仿客户端向服务器获取服务器的时间戳，然后跟前述的一样，把这两者进行拼接，再进行MD5加密，最后发送给服务器，照样能够获得客户端的登录权限；
     为了避免上述情况的发生，在开发之前，在此处客户端和服务器端应该提前约定好一个规则（拟定一个字符串），当用户输入完登录密码，按下登录按钮的时候，先用HMAC加密方式把密码进行加密，然后向服务器请求它当前的时间戳，然后把之前经过加密的密码和之前拟定好的字符串以及时间戳拼接在一起，然后再进行MD5加密，最后把加密结果发送给服务器。因为第三方不可能知道约定的规则（拟定的字符串）所以当第三方窃取到经过加密的密码和服务器的时间戳以后也不能获得客户端的登录权限，从而保证了客户端的安全。
     */
    NSString *timestamp = @"201812110007";  //向后台请求的时间戳
    NSString *promissoryStr = @"abc";  //客户端和服务器端约定的字符串
    NSString *encryptStr = [[hmacPwd stringByAppendingString:timestamp] stringByAppendingString:promissoryStr].md5String;  //加密后的字符串（将要传递给服务器的）
    NSLog(@"将要发送给服务器的字符串：%@", encryptStr);
}

@end
